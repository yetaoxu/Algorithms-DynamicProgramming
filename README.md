# AlgorithmsDynamicProgramming

## 动态规划算法的核心就是记住已经解决过的子问题的解，空间换时间

大多数动态规划问题都能被归类成两种类型：
(1)优化问题
(2)组合问题
优化问题希望你选择一个可行的解决方案，以便最小化或最大化所需函数的值。组合问题希望你弄清楚做某事方案的数量或某些事件发生的概率。

解决方案的对比：自上而下或者自下而上
以下是两种不同的动态规划解决方案：
自上而下：你从最顶端开始不断地分解问题，直到你看到问题已经分解到最小并已得到解决，之后只用返回保存的答案即可。这叫做记忆存储。
自下而上：你可以直接开始解决较小的子问题，从而获得最好的解决方案。在此过程中，你需要保证在解决问题之前先解决子问题。这可以称为表格填充算法。

代码以斐波那契数列为例。

对比递归：

斐波那契数列使用递归方法实现：
```
int fib(int n)
{
    if(n <= 0)
        return 0;
    if(n == 1)
        return 1;
    return fib(n - 1) + fib(n - 2);
}
```
由于调用每一个函数的时候都要保留上下文，所以空间上开销也不小。这么多的子节点被重复执行，如果在执行的时候把执行过的子节点保存起来，后面要用到的时候直接查表调用的话可以节约大量的时间。


参考：https://baijiahao.baidu.com/s?id=1635388976060265522&wfr=spider&for=pc
    https://blog.csdn.net/u013309870/article/details/75193592
    https://blog.csdn.net/xxx823952375/article/details/26341385
