# AlgorithmsDynamicProgramming

## 动态规划算法的核心就是记住已经解决过的子问题的解，空间换时间

大多数动态规划问题都能被归类成两种类型：
(1)优化问题
(2)组合问题
优化问题希望你选择一个可行的解决方案，以便最小化或最大化所需函数的值。组合问题希望你弄清楚做某事方案的数量或某些事件发生的概率。

解决方案的对比：自上而下或者自下而上
以下是两种不同的动态规划解决方案：
自上而下：你从最顶端开始不断地分解问题，直到你看到问题已经分解到最小并已得到解决，之后只用返回保存的答案即可。这叫做记忆存储。
自下而上：你可以直接开始解决较小的子问题，从而获得最好的解决方案。在此过程中，你需要保证在解决问题之前先解决子问题。这可以称为表格填充算法。

代码以斐波那契数列为例。

对比递归：

#### 斐波那契数列使用递归方法实现：
时间复杂度为O(2^n)指数级，空间复杂度为O(n)
```
int fib(int n)
{
    if(n <= 0)
        return 0;
    if(n == 1)
        return 1;
    return fib(n - 1) + fib(n - 2);
}
```
由于调用每一个函数的时候都要保留上下文，所以空间上开销也不小。这么多的子节点被重复执行，如果在执行的时候把执行过的子节点保存起来，后面要用到的时候直接查表调用的话可以节约大量的时间。

#### 尾递归实现：
尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。
精髓：尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。
```
int FibonacciTailRecursive(int n, int ret1, int ret2)
{
    if(n == 0)   
        return ret1; 
    return FibonacciTailRecursive(n-1, ret2, ret1+ret2);
}
```

#### 使用DP
时间复杂度为O(n), 空间复杂度为O(1)
```
int fib(int n)
{
    int a = 0, b = 1, c;
    if (n == 0)
        return 0;
    for (int i = 2; i <= n; i++)
    {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}
```

参考：https://baijiahao.baidu.com/s?id=1635388976060265522&wfr=spider&for=pc
    https://blog.csdn.net/u013309870/article/details/75193592
    https://blog.csdn.net/xxx823952375/article/details/26341385
